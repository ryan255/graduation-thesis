目   录
第一章 绪论	2
1.1 选题背景及意义	2
1.2 技术背景 3
1.3 在入侵检测应用中应用决策树分类算法的优点	6
1.4 本章小结	7
第二章 分布式架构的部署	8
第三章 网络入侵检测的决策树数据挖掘分析	9
结论（总结及展望）	10
致 谢	12
参考文献	13





# 基于kafka redis oracle 的分布式存储架构应用研究

吴瀚元

## 摘 要：

在大型电子商务网站业务量飞速增长的今天，传统的数据存储架构愈发的无法满足新时代电子商务网站在响应速度、可扩展性、容灾性等方面的需求。人们需要一种低成本的、可扩展的、高性能的大规模存储解决方案。数据库的种类众多，而其中以key-value数据库与传统关系型数据为代表，而key-value数据库中以redis为代表，关系型数据库以Oracle数据库为代表。本文主要是对大型存储的需求进行分析，针对电商网站的的特点，同时使用两种数据库并使用kafka作为中间件来同步数据，既利用了redis数据库易扩展高效率的特点，又利用传统数据库稳定性。这一改进，不但提高了电商网站的访问效率，而且还能够方便的与客户已有的IT系统对接。测试结果表明，本数据库存储架构的性能能够满足业务需求，与传统方式对比，效率大大提升。

关键字：kakfa；redis；oracle；数据库







## 第一章 绪论

### 1.1 选题背景及意义

随着电子商务网站的快速发展，客户量与业务量的急速增长给数据库提出了更多的要求，而传统的数据库架构存在体积臃肿、扩展性不足、效率低下等问题，而新型的key-value数据库在较小数据量时性能虽然高，但是性能受限于物理内存的限制，不能独立用作海量数据的高性能读写上。而且，一个大型的独立品牌电商网站在后台必然会与其原有IT系统的对接需求，单独某种单一数据库结构难以满足需求。

既然单独应用两种数据库都无法解决问题，那么将两者结合在一起就成为了我们的选择。而要将两者结合，其中最主要解决的问题就是数据同步。为了保证数据同步的实时性和扩展能力，我们需要一种可水平扩展和高效率的消息系统作为数据转发的中转站。这个系统就是kafka。

在本项目中，我们将redis中的数据变化发送给kafka集群，再由一个程序接收kafka消息队列并将数据写入另一个redis数据库。同时又另一个程序负责将数据写入oracle，从而解决了redis集群与oracle的数据同步问题。

本项目具有很高的现实意义，本系统已经在优衣库官网电商平台项目上得到实施，作为项目中的数据库架构，给前后端服务提供了稳定的、可扩展的支持。本架构弥补了行业中oracle数据库与redis数据库同步的技术空白，为以后相关架构的发展提供了可靠的依据。

### 1.2 技术背景

本项目中使用的技术主要有：redis、oracle数据库、kafka和spring-boot。

本项目使用Redis 3.2.5版本。Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。[1]

 Redis 内置了 复制（replication）， LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction）， 事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel） 和自动 分区（Cluster）提供高可用性（high availability）。[3]

本项目使用Oracle Database 11XE版本。Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。[2]

本项目使用kafka 0.10.2.0版本。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 [5]

![kafka-apis](/Users/wuhanyuan/githubproject/graduation-thesis/kafka-apis.png)

它最初由LinkedIn公司开发，之后成为Apache项目的一部分。通常被用作构建实时的数据通道，它是水平可扩展的，分布式的，快速的[6]。

本项目使用Spring-Boot 1.4.0版本。Spring Boot是Spring社区较新的一个项目。该项目的目的是帮助开发者更容易的创建基于Spring的应用程序和服务，让更多人的人更快的对Spring进行入门体验，让Java开发也能够实现Ruby on Rails那样的生产效率[4]。为Spring生态系统提供了一种固定的、约定优于配置风格的框架。Spring Boot具有如下特性[8]：

1. 为基于Spring的开发提供更快的入门体验
2. 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。
3. 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康
4. Spring Boot并不是不对Spring功能上的增强，而是提供了一种快速使用Spring的方式。

spring-boot的应用大大减少了开发中的配置任务，加快了开发进程。而且它提供的spring-data-redis库为操作redis数据库提供了良好的支持[9]。

另外，本项目使用maven作为项目构建工具，使用github作为版本控制工具。

### 1.3 本章小结

本章介绍了开发本数据库架构的背景及意义，同时也指出了开发中要解决的核心问题是数据同步。简要介绍了本项目中使用到的主要技术及其技术背景。结合项目中对技术的实际使用，在技术介绍中分析了使用相关技术路线的优势。

## 第二章 分布式架构的部署

### 2.1 整体结构说明 

![hmall数据同步流程-从redis1操作](/Users/wuhanyuan/githubproject/graduation-thesis/hmall数据同步流程-从redis1操作.png)

项目的整体结构如图2-1所示。本项目中涉及分布式部署的模块有kafka与redis两种。为了降低组建之间的耦合度提高稳定性和扩展性，项目中使用了2个kafka集群作为数据中间件，负责数据的转发。mirrirmaker是一个kafka的组件，能够实现两个kafka集群中的数据复制。左右两侧两个redis数据库集群，代表应用环境中两个不同地理位置的数据中心，而下方的oracle数据库则作为备份数据库使用。

### 2.2 kafka集群

Kafka的整体架构是显式分布式架构，producer、broker（kafka）和consumer都可以有多个。Producer，consumer实现Kafka注册的接口，数据从producer发送到broker，broker承担一个中间缓存和分发的作用。broker分发注册到系统中的consumer。broker的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。客户端和服务器端的通信，是基于简单，高性能，且与编程语言无关的TCP协议[6]。几个基本概念：

1. Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。
2. Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。
3. Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。
4. Producers：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。
5. Consumers：消息和数据消费者，订阅topics并处理其发布的消息的过程叫做consumers。
6. Broker：缓存代理，Kafa集群中的一台或多台服务器统称为broker。

在本项目中，每个kakfa集群有由3个kafka-server与一个zookeeper组成。每个数据流动方向使用一个独立的Topic，比如从redis1到redis2的数据流使用一个叫test1的topic。Producers与Consumers则通过kafka提供的java的api来实现。发送的Message即为数据同步所需的数据变化信息（主要包含add、update、delete三种操作类型及其数据）。



### 2.3 redis集群

redis集群部署非常简单。修改redis.conf中关于数据库集群节点以及IP地址与端口的相关配置，重新启动redis数据库即可。在应用环境中，每个redis集群由三台redis服务器节点组成。而在生产环境中，受限于设备硬件性能，我们使用单节点的伪集群部署。

### 2.4 本章小结

本章主要介绍了项目在架构上的整体设计，着重介绍了kakfa集群的几个基本概念。同时描述了kafka与redis在本项目中的部署情况。环境的部署为整个项目的运作提供了基础支持，而项目的可扩展性也依赖于这些组件本身。其中，kafka的扩展能力尤为重要，我们期望它的吞吐量能够随着模块的增加线性增长，这一点会在第四章得到验证。

##第三章 数据同步

### 3.1 数据

解决数据同步问题要先考虑数据是如何产生的。对于本项目的应用背景（一个电商平台）而言，数据操作无非是add、update和delete的组合。所以，只要能收集到操作类型、操作的目标（oracle中的表或者redis中的HashValue）、操作的数据（每个字段以及对应的值），我们就可以将数据原封不动的“同步”到另一个数据库中。在这里同步的本质不是复制，而是将数据操作原样执行了一遍。这就是本项目中数据同步的基本原理。

在实现中，用户在对redis1进行操作的时候，数据的增量信息（操作类型、操作的目标、数据）就会插入到redis中的一个队列（从左向右，先进先出）里。随后再由程序从右侧弹出队列，并将信息发送到Kafka集群中。

### 3.2 消息的顺序

kafka只能保证一个partition中的消息被某个consumer消费时，消息是顺序的。事实上，从Topic角度来说，消息仍不是有序的。如果你需要topic范围内的有序，那么你可以只使用一个partition，这也就是说，group中也只有一个consumer。但是在应用情况中，为了提高性能保证速度，producer与consumer都是多线程的，也就是说，同时有多个producer在生产数据，也同时有多个consumer在消费数据。这就会导致数据的无序。

add、updtae、delete数据的操作顺序的改变很明显会导致最终结果的不同，所以需要有一种机制来保证即使数据顺序不同，最终结果也是一样的。这里我们引入了“伪删除”，即删除操作是将数据从原表删除的同时存入另外一张我们称之为“删除表”的表中。下面给出三种操作类型的流程图：

add：

![hmall数据操作-add](/Users/wuhanyuan/githubproject/graduation-thesis/hmall数据操作-add.png)

如图3-1所示，在进行add操作时，先判断“删除表”中是否有同ID数据，如果有则不进行操作（这意味着本条在原始操作中顺序早于delete的add操作晚于delete操作的消息到来），否则，判断“普通表”是否有同ID数据（为了区分由于某些意外原因同样的数据被发送了两遍），如果有则不尽兴操作，否则执行add操作。

update：

![hmall数据操作-update](/Users/wuhanyuan/githubproject/graduation-thesis/hmall数据操作-update.png)

如图3-2所示，在进行update操作时，先判断“删除表”中是否有同ID数据，如果有则不进行操作（这意味着本条在原始操作中顺序早于delete的update操作晚于delete操作的消息到来），否则判断“普通表”中是否有同ID数据，如果无则将update操作转为add操作（这意味着本条在原始操作中顺序晚于add的update操作早于add操作的消息到来），如果有则判断消息的版本号，大于则执行，小于则不执行。

delete：

![hmall数据操作-delete](/Users/wuhanyuan/githubproject/graduation-thesis/hmall数据操作-delete.png)

如图3-3所示，在进行delete操作时，先判断“普通表”中是否有同ID数据，如果无，直接将删除内容插入“删除表”中，如果有则执行delete操作，再将删除内容插入“删除表”中。

通过上述三种数据操作类型的逻辑设计，我们巧妙的做到了即使消息到来的先后顺序不对，当数据操作完成时的数据结果完全相同。解决了数据同步中kafka消息的无序问题。

### 3.3 本章小结

因为数据同步是本架构要解决的最核心问题，本章主要介绍了数据同步的基本原理，着重介绍了kafka无序问题的解决。这个问题的解决打通了多个数据中心之间数据同步的通道。

## 第四章 性能与测试

### 4.1 测试环境

本文的测试共使用6台安装Red Hat 6.6的虚拟机，3台作为Broker，另外3台作为Producer或者Consumer。每台虚拟机配置如下：

1. CPU：8 vCPU， Intel(R) Xeon(R) CPU E5-2680 v2 @ 2.80GHz，2 Sockets，4 Cores per socket，1 Thread per core
2. 内存：16 GB
3. 磁盘：500 GB

### 4.2 测试方法

kafka官方提供了多种测试脚本，我们使用其中的两个进行测试：

1. `$KAFKA_HOME/bin/kafka-producer-perf-test.sh` 该脚本被设计用于测试Kafka Producer的性能，主要输出4项指标，总共发送消息量（以MB为单位），每秒发送消息量（MB/second），发送消息总数，每秒发送消息数（records/second）。除了将测试结果输出到标准输出外，该脚本还提供CSV Reporter，即将结果以CSV文件的形式存储，便于在其它分析工具中使用该测试结果。
2. `$KAFKA_HOME/bin/kafka-consumer-perf-test.sh` 该脚本用于测试Kafka Consumer的性能，测试指标与Producer性能测试脚本一样。



### 4.3 测试结果

测试一：producer数量与总吞吐量线性相关测试

测试目标：多个Producer可同时向同一个Topic发送数据，在Broker负载饱和前，理论上Producer数量越多，集群每秒收到的消息量越大，并且呈线性增涨。

测试结果：

![1228022](/Users/wuhanyuan/githubproject/graduation-thesis/1228022.png)

如图4-1所示，测试结果满足期望。即当我们多线程使用kafka生产者发消息时，kafka的吞吐量线性的增长。



测试二：消息体积大小与吞吐量关系

测试目标：找出合适的消息长度，在单条消息长度满足使用需要的同时，能够维持一定的数据吞吐速度（MB／s），理论上来说，消息越短，每秒消息吞吐量（records／s）越大，数据吞吐速度（MB／s）越小。

测试结果：

![1228024](/Users/wuhanyuan/githubproject/graduation-thesis/1228024.png)

### 4.4 本章小结

在前面的三章中，我们对项目背景、技术路线、项目中的核心问题等关键信息做了介绍。在经历了3个月左右时间的开发之后，整个项目开发完成，已经应用到了客户环境中，运行情况良好。

作为应用研究，测试必不可少。通过测试，既可以完整的测试出本项目各个模块的性能，为后续的扩展开发作为参考，又可以与传统架构做对比，以显示出本架构的优越性。

## 结论（总结及展望）

此次应用研究中，主要是基于电商平台的实际项目，应用redis、oracle两种数据库并使用kafka作为中间件的一个数据架构解决方案。在应用研究中，我们主要解决了数据同步这一关键问题，解决了增量数据的获取方法，也解决了kafka在多个producer与consumer时的无序问题。测试的结果也显示，解决了无序问题之后，kafka的扩展性得到了充分的利用，数据吞吐量随着模块数量的增多线性的增长。

作为本次应用研究而言，Redis-oracle-kafka数据库架构的“主体枝干”基本完成，但依旧保留了一些可供扩展的地方：比如oracle数据还原到redis的过程，比如缺少一个可视化的监控工具等等。

在研究过程中也走过一些弯路，比如在增量数据获取的方案中，最初使用redis自带的广播机制，忽略了增量数据的存储问题（广播消息不保存）。同时这些尝试也带给我很大的收获。虽然redis广播机制不适合作为数据获取的工具，但是在未来开发的开发中redis广播可以用来监控数据库的运行状况。

最后，希望本数据库架构能够在更多的地方得到应用，也希望更多人能够从本文中得到启发。













## 致谢

在这次毕业设计从定题到完成的整个过程中，有很多人给予我很大的帮助，我在此感谢他们。我首先要感谢我的指导老师，老师从选题到论文的写作等毕业设计各个阶段都提供了很多中肯的意见，指点迷津、指引方向。其次要感谢我的同事，他们在工作之余给了我很多技术方面的指导，包含技术路线的选择这样的大方向与一些编程语言的基础知识等。还要感谢的就是我的公司，他们提供了强大的服务器与网络资源，这些是我完成研究的硬件基础。当然还要感谢各个开源社区，没有他们就没有kakfa，也就没有我完成本次应用研究的技术前提。

谢谢你们！






参考文献
[1] Josiah L. Carlson. 《Redis IN ACTON》[M].  人民邮电出版社.2015
[2] Bob Briyla，Kevin Loney. 《Oracle Database 12c:The Complete Reference（第7版）》[M]. 清华大学出版社.2015
[3] Redislab. The Redis Documentation. https://redis.io/documentation.2002
[4] Phillip Webb, Dave Syer, Josh Long, Stéphane Nicoll, Rob Winch, Andy Wilkinson, Marcel Overdijk, Christian Dupuis, Sébastien Deleuze. Spring Boot Reference Guide. http://docs.spring.io/spring-boot/docs/1.4.6.RELEASE/reference/htmlsingle/ .2017
[5] A distributed streaming platform. http://kafka.apache.org .2017
[6] Kafka 0.10.2 Documentation. http://kafka.apache.org/documentation/ .2017
[7] Jason. Kafka性能测试方法及Benchmark报告.http://www.jasongj.com/2015/12/31/KafkaColumn5_kafka_benchmark/ .2017
[8] 汪云飞.《JavaEE开发的颠覆者：Spring Boot实战》.电子工业出版社.2016
[9] 陈韶健.《深入浅出Spring Boot》.机械工业出版社.2016
[10] 黄健宏. 《Redis设计与实现》. 机械工业出版社.2014
[11] 丁士峰. 《Oracle PL/SQL从入门到精通》.清华大学出版社 .2012
[12] Nishant Garg. 《Apache Kafka》. PACKT open source.2016
[13] 皮雄军. 《NoSQL数据库技术实战》.清华大学出版社 . 2015
[14] Sourabh，Sharma. 《Mastering Micoservices with Java》. 电子工业出版社.2017
